{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-90ad00eb868f43bd9d8d99eb6dbf87bb67782339",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/EventManager.sol": "project/contracts/EventManager.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/EventManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.28;\r\n\r\ncontract EventManager {\r\n    // ---- Reentrancy-guard ----\r\n    uint256 private _locked = 1;\r\n    modifier nonReentrant() {\r\n        require(_locked == 1, \"Reentrant call\");\r\n        _locked = 2;\r\n        _;\r\n        _locked = 1;\r\n    }\r\n\r\n    // ---- Datamodell ----\r\n    struct EventData {\r\n        address organizer;            // Skaparen/ansvarig\r\n        string name;                  // Namn\r\n        uint256 ticketPrice;          // Avgift i wei\r\n        uint256 userLimit;            // Max antal deltagare\r\n        uint256 deadline;             // Sista anmälningstid (unix timestamp)\r\n        bool isOpen;                  // Ar anmälan öppen?\r\n        uint256 sold;                 // Antal anmälda\r\n        uint256 balance;              // Ackumulerade medel för just detta event\r\n        address[] participants;       // Lista över deltagare\r\n        mapping(address => bool) registered; // Snabbkoll: har adressen anmält sig?\r\n    }\r\n\r\n    address public owner;\r\n    uint256 public nextEventId;                // Räknare för ID\r\n    mapping(uint256 => EventData) private eventsById;\r\n\r\n    \r\n    // ---- Custom errors ----\r\n    error EventNotFound();\r\n    error InsufficientPayment();\r\n    error AlreadyRegistered();\r\n    error EventFull();\r\n    error DeadlinePassed();\r\n    error OnlyOwner();\r\n    error OnlyOrganizer();\r\n    error InvalidEventData();\r\n\r\n    // ---- Events (loggar) ----\r\n    event EventCreated(uint256 indexed eventId, address indexed organizer, string name);\r\n    event RegistrationOpened(uint256 indexed eventId);\r\n    event RegistrationClosed(uint256 indexed eventId);\r\n    event Registered(uint256 indexed eventId, address indexed attendee, uint256 price);\r\n    event Withdrawn(uint256 indexed eventId, address indexed organizer, uint256 amount);\r\n\r\n    // ---- Custom modifiers ----\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) revert OnlyOwner();\r\n        _;\r\n    }\r\n    \r\n    modifier onlyOrganizer(uint256 _eventId) {\r\n        if (msg.sender != eventsById[_eventId].organizer) revert OnlyOrganizer();\r\n        _;\r\n    }\r\n\r\n    // ---- Skapa nytt evenemang ----\r\n    function createEvent(\r\n        string calldata name_,\r\n        uint256 ticketPrice_,\r\n        uint256 userLimit_,\r\n        uint256 deadline_   // absolut tid (block.timestamp-baserad)\r\n    ) external returns (uint256 eventId) {\r\n        require(bytes(name_).length > 0, \"Name required\");\r\n        require(ticketPrice_ > 0, \"ticketPrice must be > 0\");\r\n        require(userLimit_ > 0, \"userLimit must be > 0\");\r\n        require(deadline_ > block.timestamp, \"Deadline must be in the future\");\r\n\r\n        eventId = nextEventId++;\r\n        EventData storage e = eventsById[eventId];\r\n        e.organizer   = msg.sender;\r\n        e.name        = name_;\r\n        e.ticketPrice = ticketPrice_;\r\n        e.userLimit   = userLimit_;\r\n        e.deadline    = deadline_;\r\n        e.isOpen      = false; // startar stängd tills man öppnar\r\n\r\n        emit EventCreated(eventId, msg.sender, name_);\r\n    }\r\n\r\n    // ---- Öppna/Stäng anmälan ----\r\n    function openRegistration(uint256 eventId) external {\r\n        EventData storage e = _requireEventOrganizer(eventId);\r\n        require(block.timestamp < e.deadline, \"Deadline passed\");\r\n        require(!e.isOpen, \"Already open\");\r\n        e.isOpen = true;\r\n        emit RegistrationOpened(eventId);\r\n    }\r\n\r\n    function closeRegistration(uint256 eventId) external {\r\n        EventData storage e = _requireEventOrganizer(eventId);\r\n        require(e.isOpen, \"Already closed\");\r\n        e.isOpen = false;\r\n        emit RegistrationClosed(eventId);\r\n    }\r\n\r\n    // ---- Anmälan (betalning hanteras här) ----\r\n    function register(uint256 eventId) external payable nonReentrant {\r\n        EventData storage e = eventsById[eventId];\r\n        require(e.organizer != address(0), \"Event not found\");\r\n        require(e.isOpen, \"Registration closed\");\r\n        require(block.timestamp < e.deadline, \"Deadline passed\");\r\n        require(e.sold < e.userLimit, \"Sold out\");\r\n        require(!e.registered[msg.sender], \"Already registered\");\r\n        require(msg.value == e.ticketPrice, \"Wrong price\");\r\n\r\n        // Spara deltagare\r\n        e.registered[msg.sender] = true;\r\n        e.participants.push(msg.sender);\r\n        e.sold += 1;\r\n\r\n        // Bokför evenemangets kassa\r\n        e.balance += msg.value;\r\n\r\n        // Auto-stang om vi nådde max\r\n        if (e.sold == e.userLimit) {\r\n            e.isOpen = false;\r\n            emit RegistrationClosed(eventId);\r\n        }\r\n\r\n        emit Registered(eventId, msg.sender, msg.value);\r\n    }\r\n\r\n    // ---- Uttag av medel per evenemang ----\r\n    // Tillåts när registrering inte är öppen OCH (deadline passerad eller fullsatt).\r\n    function withdraw(uint256 eventId) external nonReentrant {\r\n        EventData storage e = _requireEventOrganizer(eventId);\r\n        require(!e.isOpen, \"Close registration first\");\r\n        require(block.timestamp >= e.deadline || e.sold == e.userLimit, \"Too early\");\r\n\r\n        uint256 amount = e.balance;\r\n        require(amount > 0, \"Nothing to withdraw\");\r\n        e.balance = 0;\r\n\r\n        (bool ok, ) = payable(e.organizer).call{value: amount}(\"\");\r\n        require(ok, \"Transfer failed\");\r\n\r\n        emit Withdrawn(eventId, e.organizer, amount);\r\n    }\r\n\r\n    // ---- Läsfunktioner ----\r\n    function getEventInfo(uint256 eventId)\r\n        external\r\n        view\r\n        returns (\r\n            address organizer,\r\n            string memory name,\r\n            uint256 ticketPrice,\r\n            uint256 userLimit,\r\n            uint256 deadline,\r\n            bool isOpen,\r\n            uint256 sold,\r\n            uint256 balance\r\n        )\r\n    {\r\n        EventData storage e = eventsById[eventId];\r\n        require(e.organizer != address(0), \"Event not found\");\r\n        return (e.organizer, e.name, e.ticketPrice, e.userLimit, e.deadline, e.isOpen, e.sold, e.balance);\r\n    }\r\n\r\n    function getParticipants(uint256 eventId) external view returns (address[] memory) {\r\n        EventData storage e = eventsById[eventId];\r\n        require(e.organizer != address(0), \"Event not found\");\r\n        return e.participants;\r\n    }\r\n\r\n    function isRegistered(uint256 eventId, address user) external view returns (bool) {\r\n        EventData storage e = eventsById[eventId];\r\n        require(e.organizer != address(0), \"Event not found\");\r\n        return e.registered[user];\r\n    }\r\n\r\n    // ---- Hjälpare ----\r\n    function _requireEventOrganizer(uint256 eventId) internal view returns (EventData storage e) {\r\n        e = eventsById[eventId];\r\n        require(e.organizer != address(0), \"Event not found\");\r\n        require(msg.sender == e.organizer, \"Not organizer\");\r\n    }\r\n\r\n    // Förhindra oavsiktliga insättningar\r\n    receive() external payable { revert(\"Send via register()\"); }\r\n    fallback() external payable { revert(\"Send via register()\"); }\r\n}\r\n"
      }
    }
  }
}